### raw type은 사용하지 말라
---

#### 제네릭의 정의
- 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭이라 한다.
  - 클래스와 인터페이스 선언에 타입 매개변수(type-parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라고 한다.
- 제네릭 타입을 하나 정의하면 그에 딸린 raw type도 함께 정의된다.
  - List\<E\> 의 row type은 List 이다.
  - ***제네릭 타입에서 타입 매개변수를 전혀 사용하지 않았을 때 raw type***이라 한다.

#### raw type의 위험성
- raw type을 사용할 경우 내가 원하지 않는 타입의 인스턴스를 넣어도 컴파일이 잘된다.
- ***오류는 컴파일 시점이나 IDE가 잡아주는 것이 제일 좋다.***
```java
    // Type1 인스턴스만 취급하기를 기대한다.
    private final Collection type1 = ...;

    // 실수로 Type2 인스턴스를 집어 넣었다.
    // "unchecked call" 경고를 받지만 컴파일 에러가 발생하지는 않는다.
    type1.add(type2)

    for(type : type1){
        Type1 type = (Type1) type; // ClassCastException을 던진다.
    }

    // 타입을 지정하여 오류를 최소화 하라.
    private final Collection<Type1> type1
```
> ***raw type을 사용하면 제네릭이 안겨주는 안전성과 표현력을 모두 잃는다.*** <br/>
> List\<Object\> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 raw type을 사용하면 타입 안전성을 잃는다. <br/>
> List\<Object\>가 인자로 있을 경우, List\<String\>과 같은 매개변수를 넘겨 받을 수 없기 때문에 타입 안전성이 보장되지만 raw type인 List는 어느 타입이던 넘겨 받을 수 있다. 

### 비검사 경고를 제거하라
---

#### 비검사 경고
- unchecked warning이 나오는 이유는 타입의 안전성이 보장되지 않는다는 의미이다.
  - 주로 제네릭을 사용하면 많이 발생한다.
  ```java
  HashSet<Type> set = new HashSet();
  ```
- 비검사 경고를 제거한다는 행위는 그 코드는 타입 안전성이 보장된다는 의미이기도 하다.
  - 개발자의 혼란을 줄여줄 수 있다.
  - IDE를 통해서 비검사 경고에 대한 내용을 쉽게 확인해 볼 수 있다.

#### 경고를 제거할 수 잇는 @SuppressWarnings 사용하기
1. 경고를 제거할 수 없을 때 타입이 안전하다고 확신할 수 있다면, `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨기자.
  - 타입 안전함을 검증하지 않은 채 경고를 숨기면 경고 없이 컴파일은 되겠지만, 런타잉에는 여전히 ClassCaseException을 던질 수 있다.
  - 반대로 안전하다고 생각된 비검사 경고를 그대로 두면, 진짜 문제를 알리는 새로운 경고가 나와도 눈치 채지 못할 수 있다.
2. @SuppressWarnings 애너테이션은 가능한한 좁은 범위에 적용하는 것이 좋다.
  - @SuppressWarnings 애너테이션은 개별 지역변수 부터 전체 클래스까지 선언이 가능하다.
  - 클래스 전체에 @SuppressWarnings을 달면, 해당 클래스 내에 있는 모든 경고를 제거할 수 있기 때문에 가능한한 좁은 범위에 적용하는 것이 좋다.
3. @SuppressWarnings("unchecked") 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야한다.
