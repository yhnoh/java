### 매개변수가 유효한지 검사하라

- 메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이러한 제약조건은 메서드 몸체가 실행되기 전에 검사해야 한다.
  - ex) 인덱스 값이 음수가 아니거나, 객체 참조는 null이 아니어야 한다.
- 메서드 몸체가 시작되기전에 검사를 하여 "오류는 가능한 한 빨리 잡아야 한다."는 일반 원칙의 사례이기도 하다.

#### 매개변수를 검사를 제대로 하지 못하는 경우 발생하는 문제
- 메서드가 수행되는 중간에 모호한 예외를 던질 수 있다.
  - 개발자가 생각하지 않은 에러가 발생하는 경우
- ***메서드가 잘 수행 되었지만 잘못된 결과를 반환하거나 객체를 이상한 상태로 만들어 놓아서 알 수 없는 시점에 메서드와는 관련 없는 오류를 발생시킬 수 있다.***
  - 심지어 해당 문제는 exception으로 잡히지 않으며, 다른 부서에서 해당 문제가 발생햇다고 알려주는 경우 매우 심각한 상황이 될 수 있다.
> 때문에 public, protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. (@throws 자바독 태그를 사용면 된다.)

- 자바 7에 추가된 `java.util.Objects.requireNonNull()` 메서드를 활용하여 더이상 null을 수동으로 검사하지 않아도 된다.
- public이 아닌 메서드라면 단언문을 사용해 매개변수 유효성을 검증할 수 있다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
```java
    public List<String> toList(String[] array){
        //null 비교를 안할 경우 클라이언트가 리턴받은 결과를 사용하다 NullPointerException이 발생할 수 있다.
        //String[] strings = Objects.requireNonNull(array);
        return new AbstractList<>() {
            @Override
            public String get(int index) {
                return array[index];
            }

            @Override
            public int size() {
                return array.length;
            }
        };
    }

```
  - `String[] strings = Objects.requireNonNull(array);` 해당 내용을 생략할 경우 클라이언트가 List를 어디서 가져와 사용했는지 추적하기 어려워질 수 있다.

#### 메서드 몸체 실행 전에 유효성 검사를 해야하는 규칙의 예외상황
- 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.
> 이번 아이템에서 "매개변수에 제약을 두는게 좋다"고 해석해서는 안된다. 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을 수록 좋다.

### 적시에 방어적 복사본을 만들라.
---

- 어떤 객체든 그 객체가 상태를 변경할 수 있는 메서드를 제공하지 않으면 내부를 수정하는 일은 불가능하다.
- 하지만 프로그래머의 실수로 인해서 내부를 수정하도록 허락하는 경우가 있다.
- 내부를 수정할 수 없는줄 알았지만 수정이 가능하다면 클라이언트가 의도치 않게 해당 객체의 상태를 변경할 수 있다.
  - 해당 에러는 찾기도 생각보다 힘들 수 있다.

#### 의도치 않게 내부를 수정하도록 허락한 클래스

- 해당 코드는 문제가 객체 외부에서 객체 내부의 상태를 변경할 수 있는 코드이다.
```java
public class Period{
    //Date가 가변이기 때문에 해당 객체 내부에 있는 값을 외부에서 쉽게 변경할 수 있다.
    private Date period;
    public Period(Date period) {
        this.period = period;
    }
    public Date getPeriod() {
        return period;
    }
}
```

1. 넘겨준 인자를 수정하여 해당 객체의 상태가 변경된 경우
```java
//Period를 생성한 이후 nowPeriod 인자를 통해서 Period 객체의 상태를 변경할 수 있다.
@Test
public void periodTest1(){
    Date nowPeriod = new Date();
    Period period = new Period(nowPeriod);
    //객체 외부에서 값을 변경
    nowPeriod.setYear(1992);
    //객체의 상태가 변경되었는지 확인
    assertThat(period.getPeriod().getYear()).isEqualTo(1992);
}

//Period의 생성자에서 방어적 복사를 통한 해결
public class Period{
    //... 
    
    public Period(Date period) {
        this.period = new Date(period.getTime());
    }

    //...
}

```
- ***위 상황을 해결하기 위해 생성자에서 받은 가변 매개변수를 방어적으로 복사해야 한다.***

2. 접근자 메서드가 내부의 가변 정보를 직접적으로 드러내는 경우

```java
@Test
public void periodTest2(){
    Date nowPeriod = new Date();
    Period period = new Period(nowPeriod);
    period.getPeriod().setYear(1992);
    assertThat(period.getPeriod().getYear()).isEqualTo(1992);
}

public class Period{
    //...     
    public Date getPeriod() {
        return new Date(period.getTime());
    }
    //...
}
```
- 접근자 메서드에 접근시 가변 정보를 방어적 복사본으로 반환하면 된다.

#### 방어적 복사를 하는 목적 
1. 객체를 사용하는 클라이언트들이 자신이 원하지 않을 때 객체의 상태를 변경하지 않도록 하기 위해서 방어적 복사를 사용한다.
2. 클라이언트에서 넘겨준 객체를 내부 객체에서 의도치않게 변경하지 않기 위해서 방어적 복사를 사용한다.

#### 방어적 복사를 할 때 고려할 것
- 넘겨 받은 객체가 내부에서 자료구조로 활용될 때 잠재적으로 변경될 수 있는지를 생각해야 한다.
  - 변경될 수 있는 객체라면 그 객체가 넘겨진 뒤 임의로 변경되어도 클래스가 문제 없이 동작하는지 따져봐야 한다.
  - 확신할 수 없다면 복사본을 만들어 저장해야 한다.
- 해당 객체의 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
- 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 넘겨줄 때 방어적 복사를 생략할 수 있다.
> 불변격체를 만드는 일은 성능 저하가 따르고, 항상 사용할 수 있느 것도 아니다. <br/>
> 때문에 위와 같은 이유로 방어적 복사를 하지 않을 경우 명확히 문서화 해두는 것이 좋다. <br/>
> 만약에 문서화함에도 불구하고 불변이 깨질 경우, 그 영향이 호출한 클라이언트로 국한될 때로 한정되는 것이 좋다.