### 매개변수가 유효한지 검사하라

- 메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이러한 제약조건은 메서드 몸체가 실행되기 전에 검사해야 한다.
  - ex) 인덱스 값이 음수가 아니거나, 객체 참조는 null이 아니어야 한다.
- 메서드 몸체가 시작되기전에 검사를 하여 "오류는 가능한 한 빨리 잡아야 한다."는 일반 원칙의 사례이기도 하다.

#### 매개변수를 검사를 제대로 하지 못하는 경우 발생하는 문제
- 메서드가 수행되는 중간에 모호한 예외를 던질 수 있다.
  - 개발자가 생각하지 않은 에러가 발생하는 경우
- ***메서드가 잘 수행 되었지만 잘못된 결과를 반환하거나 객체를 이상한 상태로 만들어 놓아서 알 수 없는 시점에 메서드와는 관련 없는 오류를 발생시킬 수 있다.***
  - 심지어 해당 문제는 exception으로 잡히지 않으며, 다른 부서에서 해당 문제가 발생햇다고 알려주는 경우 매우 심각한 상황이 될 수 있다.
> 때문에 public, protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. (@throws 자바독 태그를 사용면 된다.)

- 자바 7에 추가된 `java.util.Objects.requireNonNull()` 메서드를 활용하여 더이상 null을 수동으로 검사하지 않아도 된다.
- public이 아닌 메서드라면 단언문을 사용해 매개변수 유효성을 검증할 수 있다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
```java
    public List<String> toList(String[] array){
        //null 비교를 안할 경우 클라이언트가 리턴받은 결과를 사용하다 NullPointerException이 발생할 수 있다.
        //String[] strings = Objects.requireNonNull(array);
        return new AbstractList<>() {
            @Override
            public String get(int index) {
                return array[index];
            }

            @Override
            public int size() {
                return array.length;
            }
        };
    }

```
  - `String[] strings = Objects.requireNonNull(array);` 해당 내용을 생략할 경우 클라이언트가 List를 어디서 가져와 사용했는지 추적하기 어려워질 수 있다.

#### 메서드 몸체 실행 전에 유효성 검사를 해야하는 규칙의 예외상황
- 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.
> 이번 아이템에서 "매개변수에 제약을 두는게 좋다"고 해석해서는 안된다. 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을 수록 좋다.

### 적시에 방어적 복사본을 만들라.
---

- 어떤 객체든 그 객체가 상태를 변경할 수 있는 메서드를 제공하지 않으면 내부를 수정하는 일은 불가능하다.
- 하지만 프로그래머의 실수로 인해서 내부를 수정하도록 허락하는 경우가 있다.
- 내부를 수정할 수 없는줄 알았지만 수정이 가능하다면 클라이언트가 의도치 않게 해당 객체의 상태를 변경할 수 있다.
  - 해당 에러는 찾기도 생각보다 힘들 수 있다.

#### 의도치 않게 내부를 수정하도록 허락한 클래스

- 해당 코드는 문제가 객체 외부에서 객체 내부의 상태를 변경할 수 있는 코드이다.
```java
public class Period{
    //Date가 가변이기 때문에 해당 객체 내부에 있는 값을 외부에서 쉽게 변경할 수 있다.
    private Date period;
    public Period(Date period) {
        this.period = period;
    }
    public Date getPeriod() {
        return period;
    }
}
```

1. 넘겨준 인자를 수정하여 해당 객체의 상태가 변경된 경우
```java
//Period를 생성한 이후 nowPeriod 인자를 통해서 Period 객체의 상태를 변경할 수 있다.
@Test
public void periodTest1(){
    Date nowPeriod = new Date();
    Period period = new Period(nowPeriod);
    //객체 외부에서 값을 변경
    nowPeriod.setYear(1992);
    //객체의 상태가 변경되었는지 확인
    assertThat(period.getPeriod().getYear()).isEqualTo(1992);
}

//Period의 생성자에서 방어적 복사를 통한 해결
public class Period{
    //... 
    
    public Period(Date period) {
        this.period = new Date(period.getTime());
    }

    //...
}

```
- ***위 상황을 해결하기 위해 생성자에서 받은 가변 매개변수를 방어적으로 복사해야 한다.***

2. 접근자 메서드가 내부의 가변 정보를 직접적으로 드러내는 경우

```java
@Test
public void periodTest2(){
    Date nowPeriod = new Date();
    Period period = new Period(nowPeriod);
    period.getPeriod().setYear(1992);
    assertThat(period.getPeriod().getYear()).isEqualTo(1992);
}

public class Period{
    //...     
    public Date getPeriod() {
        return new Date(period.getTime());
    }
    //...
}
```
- 접근자 메서드에 접근시 가변 정보를 방어적 복사본으로 반환하면 된다.

#### 방어적 복사를 하는 목적 
1. 객체를 사용하는 클라이언트들이 자신이 원하지 않을 때 객체의 상태를 변경하지 않도록 하기 위해서 방어적 복사를 사용한다.
2. 클라이언트에서 넘겨준 객체를 내부 객체에서 의도치않게 변경하지 않기 위해서 방어적 복사를 사용한다.

#### 방어적 복사를 할 때 고려할 것
- 넘겨 받은 객체가 내부에서 자료구조로 활용될 때 잠재적으로 변경될 수 있는지를 생각해야 한다.
  - 변경될 수 있는 객체라면 그 객체가 넘겨진 뒤 임의로 변경되어도 클래스가 문제 없이 동작하는지 따져봐야 한다.
  - 확신할 수 없다면 복사본을 만들어 저장해야 한다.
- 해당 객체의 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
- 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 넘겨줄 때 방어적 복사를 생략할 수 있다.
> 불변격체를 만드는 일은 성능 저하가 따르고, 항상 사용할 수 있느 것도 아니다. <br/>
> 때문에 위와 같은 이유로 방어적 복사를 하지 않을 경우 명확히 문서화 해두는 것이 좋다. <br/>
> 만약에 문서화함에도 불구하고 불변이 깨질 경우, 그 영향이 호출한 클라이언트로 국한될 때로 한정되는 것이 좋다.


### 메서드 시그니처를 신중히 설계하라.

#### 클래스 내에 메서드를 작성할 때 고려할 것
1. 메서드 이름을 신중히 짖자
   - 항상 표준 명명 규칙에 따라야하며, 패키지에 속한 다른 이름과 일관되게 짖는 것이 최우선 목표이다.
   - 그 다음 개발자 커뮤니티에서 널리 받아지는 이름을 사용하는 것이 좋다.
   - 애매할 경우 자바 라이브러리 API 가이드를 참조하라.
2. 편의 메서드를 너무 많이 만들지 말라.
   - 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다.
   - 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
3. 매개변수 목록은 짧게 유지하자.
   - 매개변수는 4개 이하가 좋으며, 4개를 초과하게되면 매개변수를 전부 기억하기 힘드라다.
   - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
   - 과하게 긴 매개변수 목록을 짤게 줄여주는 세 가지 기술
     - 여러 메서드를 쪼갠다.
     - 매개변수 여러개를 묶어주는 도우미 클래스를 만드는 것이다.
       - 도우미 클래스는 정적 멤버 클래스로 두는 것이 명시적이여서 좋다.
     - 매개변수가 많으면서 그 일부는 생략해도 될 때, 모든 매개변수를 하나로 추상화한 클래스를 정의하고, 클라이언트에서 이 객체의 세터 메서드를 호출에 응용한다고 보면 된다. (빌더 패턴도 활용 가능)
4. 매개변수 타입으로는 클래스보다는 인터페이스가 낫다.
   - 상위 타입을 상속받은 하위 타입들을 매개변수로 넘길 수 있기 때문에 훨씬 유연해 진다.
   - 특정 클래스를 사용하면, 클라이언트에게 특정 구현체만 사용하도록 제한된다.
5. boolean을 이용하는 것 보다는 enum 타입이 낫다.
   - 열거 타입을 사용하면 코드를 읽고 쓰기 더 쉬워진다.

### 다중정의(overloading, 오버로딩)는 신중히 사용하라.

- 다중 정의 메서드는 어느 메서드를 호출할지 컴파일타임에 정해진다.

- 공개 API에서 클라이언트가 어떤 다중정의 메서드를 호출해야할지 모른다면 프로그램이 오작동하기 쉽다.
    - 다중정의로 혼동을 일으키는 상황을 피해야한다.
    - 클라이언트 입장에서는 똑같은 메서드명을 가졌는데 매개변수만 다르니 어떤걸 사용해야할지 혼동하기 쉽니다.
- 이럴 때는 다중정의 메서드를 제공하는 대신에 메서드 이름을 다르게 지어주는 것이 좋다.
- 생성자의 경우는 이름을 다르게 지어줄 수 없으니 정적 팩토리라는 대안을 활용하는 것이 좋다.
  - 객체 생성시 어떤 일을할지 이름을 지어줄 수 있으니 클라이언트 입장에서 명확하다.
- 매개변수 수가 같은 다중정의 메서드가 많더라도, 매개변수가 근본적으로 다르다면 클라이언트가 헷갈리지 않는다.
  - 근본적으로 다르다는 것은 두 타입 중 서로 어느 쪽으로든 형변환이 불가능하다는 것이다.
  - 예를 들어 ArrayList에서는 int를 받는 생성자와 Collection을 받는 생성자가 있는데, 두 생성자 중 어느 것이 호출될지 헷갈릴 일이 없다.
- 다중 정의 메서드가 동일하게 동작하지 않는다면, 클라이언트 입장에서는 헷갈릴 수 있다. 뿐만아니라 해당 매개변수가 같은 타입으로 받을 수 있다면 컴파일 시점에서 클라이언트가 고른 메서드가 동작하지 않고 다른 메서드가 동작할 수 있다.
