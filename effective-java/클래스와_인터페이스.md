### 클래스와 멤버의 접근 권한을 최소화 하라.
---

- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리한다.
  - ***오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작방식에는 클라리언트가 신경쓰지 않게끔 설계***되어 있다.

#### 접근 권한 최소화의 기본 원칙
- 기본 원칙은 ***모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.***
  - 톱 레벨 클래스 (가장 바깥의 클래스)는 패키지 외부에 공개할 필요가 없다면 `package-private`으로 선언하자.
    - package-private 클래스는 해당 패키지 이외에 API로 제공되지 않았기 때문에 클라이언트 코드를 수정할 필요 없이, 수정, 교체, 제거가 가능해지진다.
  - 클래스 접근을 정의한 이후 멤버변수도 공개할 필요가 없을 경우 `private`으로 선언하자.
    - 이후 권한을 풀어줘야하는 경우가 자주 발생하는 경우 해당 컴포넌트를 분리해야하는건 아닌지 고민해보자.
- public 클래스의 인스턴스 필드는 되도록 public이 아니여야 한다.
  - public으로 선언하면 변경에 자유로워지고, 해당 필드와 관련된 모든 값을 보장할 수 없게 된다.
  - public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지도 않다.
  - 필드를 public으로 노출하고자 할때는 상수용 public static final을 선언하는 것이 좋다.
    - 기본형 타입에 대해서만 public을 제공하는 것이 좋다.
    - 배열이나 Collection과 같은 경우에는 내부 값을 클라이언트가 수정할 수 있다.
  - 접근성을 좁히지 못하게 방해하는 요인중에 하나가 접근 수준을 상위 클래스에서 보다 좁게 설정할 수 없다는 문제가 있다.

#### 테스트 코드 작성 시 접근 권한은 어떻게?
- 테스트를 하기위한 목적으로 접근 범위를 넓히려 할 때가 있다.
  - pacakge-private까지는 허용할 수 있지만 공개 API로 만들어 버리면 안된다.
  - 다행히 테스트 코드를 테스트 대상과 같은 패키지에 두면 package-private 요소에 접근할 수 있다.

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
--- 

- 외부에서 해당 필드에 대해서 접근하고자 한다면 접근자 메서드를 사용하는 것이 좋다.
  - 해당 필드에 여러 클라이언트가 접근해 버리면 해당 내용을 수정하기가 힘들어진다.
    - `public int stock; 이라는 필드에 0보다 작으수 없다는 조건을 붙이고자 할때 클라이언트 코드를 전체 수정해야 한다.`
  - 그러므로 패키지 바깥에서 접근할 수 있는 클래스라면 접근자 메서들를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
> 예외적으로 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.


### 변경 가능성을 최소화하라.
---

- 불변으로 만들 수 없는 클래스라면 변경할 수 있는 부분을 최소화하는 것이 좋다.
- 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 모든 필드에 대해 setter를 만들지마라.
  - 어디서 값이 변경이 될지 예측하기 어려워진다.
  - 불변 객체일때 클라이언트가 해당 API를 안전하게 사용할 수 있는 이유와 비슷하다.
- 때문에 다른 합당한 이유가 없다면 private final, private을 활용하자.
- 생성자는 초기화가 완전히 끝난 상태의 객체를 생성해야 한다.
  - 확실한 이유가 없다면 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
  - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능 이점은 거의 없다.


#### <p style="color:red"> 불변 객체의 이점에 대한 설명을 다시 정리할 필요 존재</p>

- 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다.
  - String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal 등등...

#### 불변 클래스를 만드는 다섯가지 원칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
   - 하위 클래스에서 객체의 상태를 임의로 변경하는 행위를 할 수 있기 때문에 클래스를 final로 선언한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
   - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
5. 자신 외에는 내부의 가변 객체 필드에 접근할 수 없도록 한다.
   - 점근자 메서드가 가변 객체 필드를 그대로 반환해서도 안된다.
- tip) 불변 클래스의 메서드 이름으로 동사 대신 전치사를 주로 사용한다.
    ```java
    // final 클래스 선언
    public final Calculate{
        private final double number;
        public Calculate(int number){
            this.number = number;
        }

        //add와 같은 동사를 잘 사용하지 않는다.
        //새로운 객체를 반환
        public Calculate plus(Calculate calculate){
            return new Calculate(this.number + calculate.number);
        }

        //hashCode 및 equals 구현하기
    }

    ```
#### 불변 클래스를 장단점
- 장점
  - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대록 간직한다.
  - 다른 곳에서 값을 변경할 수 없으니 안전하게 사용이 가능하다.
  - 근본적으로 멀티스레드에 안전하여 따로 동기화할 필요가 없다.
  - 즉, 클라이언트의 입장에서 많은 것을 생각할 필요없이 사용이 가능하다.
- 단점
  - 값이 다르면 받드시 독립된 객체로 만들어야한다.
    - 만약 객체를 생성하는데 오랜 시간이 걸린다면 성능상 이슈가 발생할 수 있다.
    - 해당 문제를 해결하기 위해 불변 클래스의 생성을 도와주는 클래스를 제작하면 된다.
      - ex) String -> StringBuilder, StringBuffer

### 상속보다는 컴포지션을 사용하라.
---

#### 상속의 위험성
- 여기서 말하는 상속은 구현 클래스가 다른 클래스를 확장하는 상속을 이야기한다. (인터페이스 제외)
- ***상위 클래스가 배포될 때마다 내부 구현이 달라질 수 있으므로, 그 여파로 하위클래스가 오동작을 할 수 있다.***
- 내부 구현이 달라질 것을 대비해 하위 클래스에서 메서드를 제정의 한다면?
  - 상위 클래스에 메서드를 재정의할 수는 있겠지만, 이 방식은 어렵고, 자칫 오류를 내거나 성능을 떨어뜨릴 수 도 있다.
  - 하위 클래스에서는 접근할 수 없는 private 필드를 써야하는 상황이라면 재정의 자체가 힘들어 질 수 있다. 
- 상위 클래스에서 새로운 메서드를 추가하여 만든다고 할 때도 문제가 발생할 수 있다.
  - 하위 클래스가 재정의를 해야될 상황인데 재정의를 못한 경우가 발생할 수 있다.

#### 상속은 언제 안전한가?
- 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전할 수 있다.
- 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다.
- 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다.

#### 상속을 활용하는 대신 컴포지션(Composition: 구성)을 활용하리
- 상속에서의 가장 큰 문제점은 하위클래스의 메서드 재정의로 발생하는 예측할 수 없는 문제들이 있었다.
- 또한 상위 클래스의 결함이 존재하면 하위 클래스가 그 결함 까지도 그대로 승계될 수 있다.
- 이를 해결하기 위해서 ***기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 조회하게 만들자.***
  - ***기존 클래스가 새로운 클래스의 구성요소르 쓰인다는 뜻에서 이러한 설계를 컴포지션이라 한다.***
- 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환하는 방식을 '전달(forwarding)'이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
- 기존 클래스를 구성하는 새로운 클래스를 만들 경우, ***기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.***
- 위임, 다양한 디자인 패턴, 래퍼 클래스 등등 다양한 곳에서 컴포지션은 활용되고 있다.


### 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
---

#### 상속을 고려할 때 문서화의 중요성
- 상속할 때 주의점도 문서화해놓지 않은 '외부'클래스를 상속할 때 위험하다.
  - 여기서 '외부'란 프로그래머 통제권 밖에 있어서 언제 어떻게 변경될지 모른다는 의미이다.
- 때문에 ***상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.***
  - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지 담아야한다.
  - 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서화로 남겨야 한다.
  - `@ImplSpec` 태그를 활용하여 재정의에 관한 설명을 남겨보자. 자바 API내에서 많이 활용한다.
  

#### 상속을 설계할 때 고려해야 할 점 
1. ***클래스의 내부 동작 과정 중간에 끼어둘 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.***
  - 예를 들어 List의 clear 메서드는 removeRange라는 훅을 제공하고 있다.
    ```java
    public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
        protected void removeRange(int fromIndex, int toIndex) {
            ListIterator<E> it = listIterator(fromIndex);
            for (int i=0, n=toIndex-fromIndex; i<n; i++) {
                it.next();
                it.remove();
            }
        }

        public void clear() {
            removeRange(0, size());
        }
    }
    ```
2. protected로 노출해야할지 말지를 고민해보자.
  - protected를 언제 써야할지 생각해보는 방법은 하위 클래스를 만들어서 실험해보는 방법말고는 없다.
  - 하위 클래스를 여러개 만들었을때 protected 메서드를 잘 사용하지 않는다면 private으로 있어야할 가능성이 높다.
3. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.
  - 하위 클래스의 인스턴스를 만들 때 상위 클래스가 먼저 생성되므로 재정의한 메서드가 의도한대로 동작하지 않을 수 있다.
4. <p style="color:red">Cloneable과 Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적을 좋지 않다.</p>
   - clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다. (새로운 객체 생성)
   - clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
   - readObject
     - 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
   - clone의 경우 하위 클래스의 clone메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다.

> 클래스를 상속으료 설계하려면 엄청난 노력이 들고 그 클래스 안기는 제약도 상당하다.

#### 상속을 허용하지 못하게 하는 방법
- 상속용으로 설계하지 않은 클래스는 상속을 금지하게끔 설계하는 것이 좋다.
1. class를 final로 선언하여 class 자체를 재정의 하지 못하도록 한다.
2. 모든 생성자를 private으로 두고 정적 팩터리를 만들어주는 방법이 있다.

> ***상속을 허용하나 허용하지 못하나, 고려할점이 상당히 많기 때문에 상속의 정당한 이유가 없다면 컴포지션을 활용하는 것이 좋다.***


### 추상 클래스보다는 인터페이스를 우선하라.
---

#### 추상 클래스와 인터페이스의 차이점
- 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
  - 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정하는 데 커다란 제약이 있다.
  - 리스코프 치환 원칙 (Liskov Substitution Principle)
- 반면 ***인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급한다.***
  - 주된 타입외에도 다른 선택적 행위, 타입을 제공할 수 있다.

#### 인터페이스를 활용하면 어떤게 좋은가
- ***인터페이스를 활용하면 계층 구조가 없는 타입 프레임워크를 만들 수 있다.***
- 타입을 계층적으로 정의하면 해당 내용을 구조적으로 잘 표현할 수 는 있지만, 현실에서는 계층을 엄격하게 구분하기 어려움이 존재한다.
  - 소프트웨어의 유연성을 떨어트릴 수 있다.
- 또한 추상 클래스를 통해서 거대한 계층구조를 설계한다고 했을 때 하위 클래스내에서 사용하지 않는 메서드드들이 많아질 수 있다.

#### 인터페이스 활용하기
- 인터페이스의 메서드 중 구현 방법이 명확한 것이 있다면, 그 구현을 디폴트 메서드로 제공해주어 다른 프로그래머의 일감을 줄어들게 할 수 있다.
  - 해당 메서드의 문서화를 잘해두어야 한다.
- ***인터페이스와 추상 골격 클래스를 함께 제공하여, 추상 클래스와 인터페이스의 장점을 모두 취하는 방법이 있다.***
  1. 인터페이스를 필드에 두고, 추상 클래스에서 실행 순서를 제공한다.
     - 추상 클래스의 타입을 따라가게 된다.
  2. 인터페이스를 implement한 추상클래스를 만들어 해당 인터페이스의 일부 메소드를 구현한다.
     - 인터페이스의 타입을 따라갈 수 있기 때문에 유연한 확장이 가능해진다.
     - 관례상 `Abstract + 인터페이스의 이름`으로 지어주는 것이 좋다.
        ```java
        public abstract class AbstractCollection<E> implements Collection<E> { 
            //...
        }
        ```
 - 인터페이스에서 Object 메서드를 디폴트 메서드로 제공해서는 안된다.
 - 구현을 원하는 메서드의 경우, `UnsupportedOperationException`을 활용하자.
   - 해당 메서드를 구현하지 않으면 프로그래마가 구현을 해야한다고 알려줄 수 있다.
 
#### 인터페이스는 구현하는 쪽을 생각해서 설계하라.

- 기존 인터페이스에서 새로운 메서드르 추가하는 일은 생각보다 쉽지 않다.
  - 추가를 원하는 메서드가 이미 구현되어 있는 구현체들의 충돌을 일으키지는 않는지 고려해야한다.
  - 특히 디폴트 메서드의 경우에는 IDE에서도 잡아 줄 수 없기 때문에 런타임시 에러가 발생하여 더 세심한 고려가 필요하다.
- 때문에 인터페이스를 배포하기 전에 최대한 구현하는 쪽을 생각하여 설계하는 것이 좋다.
  - 해당 API를 클라이언트가 사용하기 전에 미리 몇개정도 구현하여 테스트해보는 것이 좋다.
> 소프트웨어의 복잡도는 나날히 증가하고 있으며 빠른 배포를 원하는 상황에서 이러한 것들을 최대한 고려하는 것이 맞지만 실무를 하고 있는 상황에서는 쉽지 않을거라고 예상한다.<br/>
> ***내가 생각하는 소프트웨어의 가장 큰 미학은 바로 수정이다. 때문에 수정이 쉽지않아도 언제든지 수정을 할 수 있는 지식을 최대한 많이 가지고 있는것이 더 바람직하지 않을까?***
