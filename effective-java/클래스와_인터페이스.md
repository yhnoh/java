### 클래스와 멤버의 접근 권한을 최소화 하라.
---

- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리한다.
  - ***오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작방식에는 클라리언트가 신경쓰지 않게끔 설계***되어 있다.

#### 접근 권한 최소화의 기본 원칙
- 기본 원칙은 ***모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.***
  - 톱 레벨 클래스 (가장 바깥의 클래스)는 패키지 외부에 공개할 필요가 없다면 `package-private`으로 선언하자.
    - package-private 클래스는 해당 패키지 이외에 API로 제공되지 않았기 때문에 클라이언트 코드를 수정할 필요 없이, 수정, 교체, 제거가 가능해지진다.
  - 클래스 접근을 정의한 이후 멤버변수도 공개할 필요가 없을 경우 `private`으로 선언하자.
    - 이후 권한을 풀어줘야하는 경우가 자주 발생하는 경우 해당 컴포넌트를 분리해야하는건 아닌지 고민해보자.
- public 클래스의 인스턴스 필드는 되도록 public이 아니여야 한다.
  - public으로 선언하면 변경에 자유로워지고, 해당 필드와 관련된 모든 값을 보장할 수 없게 된다.
  - public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지도 않다.
  - 필드를 public으로 노출하고자 할때는 상수용 public static final을 선언하는 것이 좋다.
    - 기본형 타입에 대해서만 public을 제공하는 것이 좋다.
    - 배열이나 Collection과 같은 경우에는 내부 값을 클라이언트가 수정할 수 있다.
  - 접근성을 좁히지 못하게 방해하는 요인중에 하나가 접근 수준을 상위 클래스에서 보다 좁게 설정할 수 없다는 문제가 있다.

#### 테스트 코드 작성 시 접근 권한은 어떻게?
- 테스트를 하기위한 목적으로 접근 범위를 넓히려 할 때가 있다.
  - pacakge-private까지는 허용할 수 있지만 공개 API로 만들어 버리면 안된다.
  - 다행히 테스트 코드를 테스트 대상과 같은 패키지에 두면 package-private 요소에 접근할 수 있다.

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
--- 

- 외부에서 해당 필드에 대해서 접근하고자 한다면 접근자 메서드를 사용하는 것이 좋다.
  - 해당 필드에 여러 클라이언트가 접근해 버리면 해당 내용을 수정하기가 힘들어진다.
    - `public int stock; 이라는 필드에 0보다 작으수 없다는 조건을 붙이고자 할때 클라이언트 코드를 전체 수정해야 한다.`
  - 그러므로 패키지 바깥에서 접근할 수 있는 클래스라면 접근자 메서들를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
> 예외적으로 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.


### 변경 가능성을 최소화하라.
---

- 불변으로 만들 수 없는 클래스라면 변경할 수 있는 부분을 최소화하는 것이 좋다.
- 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 모든 필드에 대해 setter를 만들지마라.
  - 어디서 값이 변경이 될지 예측하기 어려워진다.
  - 불변 객체일때 클라이언트가 해당 API를 안전하게 사용할 수 있는 이유와 비슷하다.
- 때문에 다른 합당한 이유가 없다면 private final, private을 활용하자.
- 생성자는 초기화가 완전히 끝난 상태의 객체를 생성해야 한다.
  - 확실한 이유가 없다면 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
  - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능 이점은 거의 없다.


#### <p style="color:red"> 불변 객체의 이점에 대한 설명을 다시 정리할 필요 존재</p>

- 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다.
  - String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal 등등...

#### 불변 클래스를 만드는 다섯가지 원칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
   - 하위 클래스에서 객체의 상태를 임의로 변경하는 행위를 할 수 있기 때문에 클래스를 final로 선언한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
   - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
5. 자신 외에는 내부의 가변 객체 필드에 접근할 수 없도록 한다.
   - 점근자 메서드가 가변 객체 필드를 그대로 반환해서도 안된다.
- tip) 불변 클래스의 메서드 이름으로 동사 대신 전치사를 주로 사용한다.
    ```java
    // final 클래스 선언
    public final Calculate{
        private final double number;
        public Calculate(int number){
            this.number = number;
        }

        //add와 같은 동사를 잘 사용하지 않는다.
        //새로운 객체를 반환
        public Calculate plus(Calculate calculate){
            return new Calculate(this.number + calculate.number);
        }

        //hashCode 및 equals 구현하기
    }

    ```
#### 불변 클래스를 장단점
- 장점
  - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대록 간직한다.
  - 다른 곳에서 값을 변경할 수 없으니 안전하게 사용이 가능하다.
  - 근본적으로 멀티스레드에 안전하여 따로 동기화할 필요가 없다.
  - 즉, 클라이언트의 입장에서 많은 것을 생각할 필요없이 사용이 가능하다.
- 단점
  - 값이 다르면 받드시 독립된 객체로 만들어야한다.
    - 만약 객체를 생성하는데 오랜 시간이 걸린다면 성능상 이슈가 발생할 수 있다.
    - 해당 문제를 해결하기 위해 불변 클래스의 생성을 도와주는 클래스를 제작하면 된다.
      - ex) String -> StringBuilder, StringBuffer

### 상속보다는 컴포지션을 사용하라.
---

#### 상속의 위험성
- 여기서 말하는 상속은 구현 클래스가 다른 클래스를 확장하는 상속을 이야기한다. (인터페이스 제외)
- ***상위 클래스가 배포될 때마다 내부 구현이 달라질 수 있으므로, 그 여파로 하위클래스가 오동작을 할 수 있다.***
- 내부 구현이 달라질 것을 대비해 하위 클래스에서 메서드를 제정의 한다면?
  - 상위 클래스에 메서드를 재정의할 수는 있겠지만, 이 방식은 어렵고, 자칫 오류를 내거나 성능을 떨어뜨릴 수 도 있다.
  - 하위 클래스에서는 접근할 수 없는 private 필드를 써야하는 상황이라면 재정의 자체가 힘들어 질 수 있다. 
- 상위 클래스에서 새로운 메서드를 추가하여 만든다고 할 때도 문제가 발생할 수 있다.
  - 하위 클래스가 재정의를 해야될 상황인데 재정의를 못한 경우가 발생할 수 있다.

#### 상속은 언제 안전한가?
- 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전할 수 있다.
- 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다.
- 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다.

#### 상속을 활용하는 대신 컴포지션(Composition: 구성)을 활용하리
- 상속에서의 가장 큰 문제점은 하위클래스의 메서드 재정의로 발생하는 예측할 수 없는 문제들이 있었다.
- 또한 상위 클래스의 결함이 존재하면 하위 클래스가 그 결함 까지도 그대로 승계될 수 있다.
- 이를 해결하기 위해서 ***기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 조회하게 만들자.***
  - ***기존 클래스가 새로운 클래스의 구성요소르 쓰인다는 뜻에서 이러한 설계를 컴포지션이라 한다.***
- 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환하는 방식을 '전달(forwarding)'이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
- 기존 클래스를 구성하는 새로운 클래스를 만들 경우, ***기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.***
- 위임, 다양한 디자인 패턴, 래퍼 클래스 등등 다양한 곳에서 컴포지션은 활용되고 있다.
