### 배열

- 배열은 크기가 정해진 데이터의 공간이며, 한번 크기가 정해지면 변경할 수 없다.
    - 때문에 배열의 크기를 변경하기 위해서는 새로운 배열을 만들어주어야한다.
- 배열의 각 요소는 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작한다. O(1)
- 배열 요소의 순서를 변경하기 위해서는 최악의 경우 모든 요소를 이동 시켜야한다. O(n)
- 배열은 데이터의 삽입, 삭제
- 추가, 삽입, 삭제의 경우는 어렵지만 데이터의 요소를 찾기에 유리한 자료구조이다.
-

### 링크드 리스트

- 링크드 리스트는 데이터의 공간이 연결된 형태로 되어있는 자료구조이다.
    - 때문에 링크드 리스트는 크기의 변경에 유리하다.
- 링크드 리스트는 각 요소가 데이터와 다음 요소를 가리키는 주소를 가지고 있다.
- 링크드 리스트는 데이터의 추가, 삭제가 용이하다. O(1)
- 링크드 리스트는 데이터의 접근이 불편하다. O(n)
- 링크드 리스트는 데이터의 요소를 찾기에 어렵지만 데이터의 추가, 삭제가 용이한 자료구조이다.

### 이진 탐색

- 이진 탐색은 정렬된 배열에서 특정한 값을 찾는 알고리즘이다.
- 이진 탐색은 배열의 중간값을 기준으로 찾고자 하는 값과 비교하여 찾고자 하는 값이 중간값보다 작으면 왼쪽, 크면 오른쪽으로 이동하여 탐색한다.

### 재귀 함수

### 정렬

- 정렬은 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.

#### 버블 정렬

- 버블 정렬은 인접한 두 요소를 비교하여 정렬하는 알고리즘이다.

#### 선택 정렬

#### 삽입 정렬

### 스택, 큐

### 해쉬 테이블

- 해쉬 테이블읜 키(Key)에 데이터(Value)를 저장하는 데이터 구조이다.
    - 해시 테이블은 키를 ***해쉬 함수를 통해 임의의 값으로 변한한 뒤에 해당 값을 배열의 인덱스로 사용***하여 데이터를 저장하거나 검색한다.
    - 해쉬 함수를 통해서 인덱스를 만들기 때문에 인덱스가 중복되어 충돌이 발생할 수 있다.
    - 이러한 충돌을 아래와같은 방법을 통해
        - 체이닝
        - 오픈 어드레싱
- 해쉬 테이블은 배열을 이용하여 데이터를 저장하므로 저장공간이 많이 필요하다.
-
- 해쉬는 데이터를 저장할 때 특정한 함수를 사용하여 데이터의 위치를 찾아내는 자료구조이다.
- 맵 구조 또한 배열로 이루어져있다. 해당 클래스의 해쉬를 통해서 배열 인덱스에 저장하게 된다.
- HashMap 내부를 확인해보면 해당 클래스의 해쉬를 통해 배열 인덱스에 저장하게 된다.
- 해쉬구조는 충돌(collision)이 일어날 수 있다. 이를 해결하기 위해서는 다양한 방법이 존재한다.
    - 체이닝
    - 오픈 어드레싱

```java
    static int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

```

### 트리 (Tree)
- 트리는 ***노드와 노드로 이루어진 계층형 비선형 자료 구조***이다.

  0 1 2 3 4 5 6
  null 1 2 3 4 5 6

### 완전 이진 트리 (Complete Binary Tree)

- 배열을 통해서 완전 이진 트리로 표현할 수 있다.
  - 현재 인덱스 * 2 -> 왼쪽 자식의 인덱스
  - 현재 인덱스 * 2 + 1 -> 오른쪽 자식의 인덱스
  - 현재 인덱스 / 2 -> 부모 노드의 인덱스
- 배열을 통해서 완전이진트리르 표현할 수 있다.

### 이진 트리 먼저 알아보기

#### 트리 순회

- 트리 순회는 트리의 노드를 특정 순서로 방문하는 과정을 말한다.
- 트리 순회에는 아래와 같은 방법이 있다.
    - 전위 순회(Pre-order)
        - 루트 -> 왼쪽 -> 오른쪽
    - 중위 순회(In-order)
        - 왼쪽 -> 루트 -> 오른쪽
    - 후위 순회(Post-order)
        - 왼쪽 -> 오른쪽 -> 루트

### 힙
- 힙의 경우에는 최솟값과 최댓값을 빠르게 찾아야하는 문제에서 자주 사용된다.
- 
- 
- 힙은 데이터의 ***최대값 또는 최소값을 빠르게 찾기 자료구조***이다.
    - 완전 이진 트리형태를 가지고 있으며 부모 노드는 자식 노드보다 우선순위가 높은 값을 가지고 있다.
- 루트 노드의 자식 노드가 두번째 우선순위를 가지고 있다.
- 힙의 삽입
    - 원소를 맨 마지막에 삽입한 이후 부모노드와 비교하며 위치를 변경한다.
    - 만약 부모노드보다 우선순위가 높지 않으면 정렬을 수행하지 않는다.
    - 정렬을 수행할 수 없을 때까지 부모노드와 비교하며 위치를 변경한다.
- 힙의 삭제
    - 루트 노드를 삭제한 이후 마지막 노드가 루트 노도로 이동한다.
    - 루토 노드는 자식 노드와 비교하며 위치를 변경한다. 이때 자식 노드 중 우선순위가 높은 노드의 위치를 변경한다.
    - 만약 자식노드가 우선순위가 높지 않으면 정렬을 수행하지 않는다.
    - 정렬을 수행할 수 없을 때까지 자식 노드와 비교하며 위치를 변경한다.
- 힙의 삽입과 삭제에서 공통점은 마지막 노드를 정렬할 수 없을때 까지 비교해가며 위치를 변경하는 것이다.
- 힙의 삽입과 삭제를 할때, 트리의 길이만큼 정렬을 수행하게되므로 O(logN)의 시간복잡도를 가진다.

- 우선순위 큐(Priority Queue)

### DFS와 BFS
- BFS와 DFS 문제의 경우에는 모든 경우의 수를 탐색해야하는 문제에서 자주 사용된다.
- 
### 깊이 우선 탐색(Depth-First Search, 깊이 우선 탐색)

- BFS는 트리나 그래프와 같은 구조에서 하나으 시작점에서 탐색할 수 있을 만큼 탐색한 이후, 더 이상 탐색할 수 없을 경우 인접한 노드를 탐색한다.
    - DFS는 스택 또는 재귀함수를 통해 구현할 수 있다.
- 가장 인접한 노드를 먼저

### 너비 우선 탐색(BFS: Breadth-First Search)

- DFS는 트리나 그래프와 같은 구조에서 하나의 시작점에서 인접한 노드를 모두 탐색한 이후, 다음 인접한 노드를 탐색한다.
    - BFS는 큐를 통해 구현할 수 있다.

- 그래프에서 동일한 레벨의 노드를 먼저 방문한 이후 다음 레벨의 노드로 이동하며 탐색한다.
