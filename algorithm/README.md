
### 배열
- 배열은 크기가 정해진 데이터의 공간이며, 한번 크기가 정해지면 변경할 수 없다.
  - 때문에 배열의 크기를 변경하기 위해서는 새로운 배열을 만들어주어야한다.
- 배열의 각 요소는 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작한다. O(1)
- 배열 요소의 순서를 변경하기 위해서는 최악의 경우 모든 요소를 이동 시켜야한다. O(n)
- 배열은 데이터의 삽입, 삭제
- 추가, 삽입, 삭제의 경우는 어렵지만 데이터의 요소를 찾기에 유리한 자료구조이다.
-  
### 링크드 리스트
- 링크드 리스트는 데이터의 공간이 연결된 형태로 되어있는 자료구조이다.
  - 때문에 링크드 리스트는 크기의 변경에 유리하다.
- 링크드 리스트는 각 요소가 데이터와 다음 요소를 가리키는 주소를 가지고 있다.
- 링크드 리스트는 데이터의 추가, 삭제가 용이하다. O(1)
- 링크드 리스트는 데이터의 접근이 불편하다. O(n)
- 링크드 리스트는 데이터의 요소를 찾기에 어렵지만 데이터의 추가, 삭제가 용이한 자료구조이다.

### 이진 탐색
- 이진 탐색은 정렬된 배열에서 특정한 값을 찾는 알고리즘이다.
- 이진 탐색은 배열의 중간값을 기준으로 찾고자 하는 값과 비교하여 찾고자 하는 값이 중간값보다 작으면 왼쪽, 크면 오른쪽으로 이동하여 탐색한다.

### 재귀 함수

### 정렬
- 정렬은 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.

#### 버블 정렬
- 버블 정렬은 인접한 두 요소를 비교하여 정렬하는 알고리즘이다.

#### 선택 정렬

#### 삽입 정렬


### 스택, 큐

### 해쉬 테이블
- 해쉬 테이블읜 키(Key)에 데이터(Value)를 저장하는 데이터 구조이다.
  - 해시 테이블은 키를 ***해쉬 함수를 통해 임의의 값으로 변한한 뒤에 해당 값을 배열의 인덱스로 사용***하여 데이터를 저장하거나 검색한다.
  - 해쉬 함수를 통해서 인덱스를 만들기 때문에 인덱스가 중복되어 충돌이 발생할 수 있다.
  - 이러한 충돌을 아래와같은 방법을 통해
    - 체이닝
    - 오픈 어드레싱
- 해쉬 테이블은 배열을 이용하여 데이터를 저장하므로 저장공간이 많이 필요하다.
- 
- 해쉬는 데이터를 저장할 때 특정한 함수를 사용하여 데이터의 위치를 찾아내는 자료구조이다.
- 맵 구조 또한 배열로 이루어져있다. 해당 클래스의 해쉬를 통해서 배열 인덱스에 저장하게 된다.
- HashMap 내부를 확인해보면 해당 클래스의 해쉬를 통해 배열 인덱스에 저장하게 된다.
- 해쉬구조는 충돌(collision)이 일어날 수 있다. 이를 해결하기 위해서는 다양한 방법이 존재한다.
  - 체이닝
  - 오픈 어드레싱
```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

```


### 트리
- 트리는 노드와 노드의 연결로 이루어진 비선형 자료구조이다.

### 이진 트리 먼저 알아보기
#### 트리 순회
- 트리 순회는 트리의 노드를 특정 순서로 방문하는 과정을 말한다.
- 트리 순회에는 아래와 같은 방법이 있다.
  - 전위 순회(Pre-order)
    - 루트 -> 왼쪽 -> 오른쪽
  - 중위 순회(In-order)
    - 왼쪽 -> 루트 -> 오른쪽
  - 후위 순회(Post-order)
    - 왼쪽 -> 오른쪽 -> 루트

### 깊이 우선 탐색(Depth-First Search, 깊이 우선 탐색)
- BFS는 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
- 그래프에서 

### 너비 우선 탐색(BFS: Breadth-First Search)
- BFS는 그래프에서 가까운 부분을 우선적으로 탐색하는 알고리즘이다.
- 그래프에서 동일한 레벨의 노드를 먼저 방문한 이후 다음 레벨의 노드로 이동하며 탐색한다.
